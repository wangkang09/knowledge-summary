[TOC]

# Spring AOP 

## 循环依赖问题

* 在bean初始化的时候，如果有依赖的bean则先去创建依赖的bean，这样就会像死锁的循环等待队列一样，它也是有一个循环依赖队列
  * 互斥条件 
  * 请求保持条件
  * 不可剥夺条件
  * 循环等待条件
* 有两种依赖模式：属性依赖，构造函数依赖
* 创建的全过程
  * 读取并解析指定的XML配置文件并解析
  * 通过解析将XML内容映射到相应的BeanDefinition
  * 并将BeanDefinition注册到BeanDefinitionRegistry中（即相应的BeanFactory中，因为BeanFactory实现类都实现了BeanDefinitionRegistry）
  * 这样所有的bean定义信息都注册到了BeanFactory中，之后就可以通过BeanFactory实例化bean了
  * 实例化bean的时候，先通过反射调用构造器进行初始化，如果有依赖bean就先去初始化依赖的bean
    * 调用构造器进行初始化时，如果没有设置，则默认使用无参构造器，如果有多个构造器，则设置XML时，只能指定一个构造器
  * 在进行属性的注入，如果有依赖的bean，先去初始化依赖bean
* 问题的发现
  * 递归创建bean的时候，发现又一次要创建当前的bean
* 问题的解决
  * 因为在调用构造器进行初始化时，该对象已经暴露出来了
  * 所以当再一次要创建当前bean时，之间把已经暴露出来的但尚未完全初始化的bean直接返回给上层依赖bean
  * 这样就可以递归回去，最后进一步完成当前bean的实例化
  * 这里要提到一定，因为返回给上层依赖bean的是当前bean的引用
  * 随着当前bean的完善，上层依赖bean的属性也不断完善
  * 但是对于构造函数依赖，它第一步初始化还没完成就要去初始化依赖bean，所以还没有初始化成功，没有暴露



## AOP 的定义

* 对于整个系统的开发，主要可分成两大模块
  * 业务功能
  * 非业务功能
* 业务功能我们通过OOP的理念，将其进一步模块化成一个个相互独立，相互解耦的小功能
* 但是对于非业务功能，如日志，权限，异常处理，事务管理等，它涉及到业务的各个部分 ，OOP的思想就无法使用
* AOP就是为了解决对业务的横向扩展而产生的理念



## AOP的分类

* 静态AOP
  * 可能就像现在的注解解释器一样，在javac编译阶段，针对相应的注解，对代码进行相应的解析，生成特定的横切代码，这样对执行阶段完全透明
  * 优点是不损失运行时的性能，缺点不灵活
* 动态AOP
  * 横切代码的织入过程，放到了系统运行阶段，可分为3种类型
    * JDK动态代理：动态代理机制，可以在运行期间，为相应接口动态生成对应的代理对象，这样就可以在运行期间，将横切代码织入到代理类中，所要织入的关注点方法，必须实现于相应的接口，因为动态代理是通过接口反射而成的
    * 动态字节码增强：通过字节码技术产生原始类的子类，并将横切代码织入到子类中，执行期间使用的是子类，如果扩展的类以及类中的实例方法声明为final，就无法对其进行子类化扩展
    * 自定义类加载器
      * 通过自定义的类加载器，在将class文件加载到虚拟机期间，按照class字节码规范，将横切代码织入到class字节中
  * 以上三种类型，分别对应编译器织入，加载器织入，运行器织入



## AOP术语

* Joinpoint：连接点，所有类的方法的前后都是连接点，Joinpoint有很多类型，但是Spring AOP自身仅支持方法执行
  * 方法执行
  * 字段设置，完全可以通过对getter和setter方法的拦截达到相同的目的
  * 构造方法调用，可以通过AspectJ来实现
* Pointcut：代表Joinpoint的表述方式，即具体到特定的方法的前后，即需要增强的方法
* Advice：通知，横切代码，即需要增强的功能
  * before advice：在Pointcut位置之前执行的横切代码
  * after advice：在Pointcut位置之后执行的横切代码
    * after returning advice：正常返回后执行
    * after throwing advice：异常返回时执行
    * after advice：不管正常和异常都执行，如同finally
  * around advice：
* Aspect：是对系统中的横切代码逻辑进行模块化封装的类，可以包含多个Pointcut和多个Advice
* Weave：就是将Advice织入到Pointcut的技术
* Target：在织入过程中，被织入横切代码的对象



## Advice顺序问题

* 当有多个advice处理同一个pointCut时，可以通过指定order，来决定执行顺序，order值越小，优先级越高
* 默认顺序是，bean声明的顺序

```xml
<bean id="pem2Advice" class="...">
    <property name="order" value="2"/>
</bean>
<bean id="pemAdvice" class="...">
    <property name="order" value="1"/>
</bean>
```



## AOP目标对象中调用另一个方法

* 当目标对象调用另一个方法时，调用的是TargetObject的方法，不是ProxyObject的方法
* 当目标对象依赖于其他对象时，我们可以通过为目标对象注入依赖对象的代理对象，来解决相应的拦截问题
* 当目标对象依赖于自身时，可以尝试将目标对象的代理对象公开给它，让目标对象调用**代理对象**上的相应方法
* AspectJ直接将横切代码织入目标对象，所以代理对象和目标对象是一样的，不存在这个问题