# JVM内存模型与垃圾回收

## JVM内存模型

JVM5个存储区最主要的就是栈区和堆区，**栈里存放基本数据类型和引用**，**堆里存放各种对象的实例**

**问题**：为什么堆与栈分开设计

```
答：
1. 栈存储了处理逻辑、堆存储了具体的数据，这样隔离设计更为清晰
2. 堆与栈分离，使得堆可以被多个栈共享
3. 堆保存了上下文的信息，因此只能向上增长；而堆是动态分配的
```



**栈区、堆区、程序计数器、方法区、本地方法栈**

1. 栈区

   线程私有，每个方法执行的时候都会创建一个栈帧用于存放 局部变量表、操作数栈、动态链接、方法出口

2. 堆区

   线程共享，存放对象实例，绝大多数对象的内存都在这里分配。是垃圾回收的主要区域

3. 程序计数器

   线程私有，记录线程执行的字节码的行号

4. 方法区

   线程共享，记录类信息、字段信息、方法信息等

5. 本地方法栈

   线程私有，执行本地方法

**总结**

| 名称       | 特征                             | 作用                                       | 配置                         | 异常                                |
| ---------- | -------------------------------- | ------------------------------------------ | ---------------------------- | ----------------------------------- |
| 栈区       | 线程私有，使用一段连续的内存空间 | 存放局部变量表、操作栈、动态链接、方法出口 | -XSs                         | StackOverflowError OutOfMemoryError |
| 堆         | 线程共享，生命周期与虚拟机相同   | 保存对象实例                               | -Xms -Xmx -Xmn               | OutOfMemoryError                    |
| 程序计数器 | 线程私有、占用内存小             | 字节码行号                                 | 无                           | 无                                  |
| 方法区     | 线程共享                         | 存储类加载信息、常量、静态变量等           | -XX:PermSize -XX:MaxPermSize | OutOfMemoryError                    |
| 本地方法栈 | 线程私有                         | 执行本地方法                               |                              | OutOfMemoryError                    |

- **虚拟机栈异常**：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈动态扩展时，无法申请到足够内存时会抛出OutOfMemoryError异常
- **本地方法栈**：和虚拟机异常一样
- **方法区异常**：当没有内存进行分配时，将抛出OutOfMemoryError异常
- **运行时常量池**：其实就是方法区异常
- **堆异常**：当堆中没有内存完成实例分配，其堆无法扩展时，将会抛出OutOfMemoryError异常
- **直接内存异常**：直接内存并不是虚拟机运行时数据区的一部分，用于NIO，使用Native函数库直接分配堆外内存，然后通过Java堆里的DirectByteBuffer对象引用这块区域。这样就造成了各个内存区域的总大小大于实际无论内存，从而导致动态扩展时出现OutOfMemoryError异常



## 垃圾回收

### 如何定义垃圾

```
答：有两种方式，引用计数（无法解决循环引用的问题）、可达性分析
```

### 垃圾回收方法

```
答：垃圾回收大体有四种方法
1. 标记-清除算法：将失效的对象标记，下次GC的时候统一将标记的对象回收，优点时减少停顿时间，缺点是会造成内存碎片，大致大对象无法分配内存
2. 复制回收算法：将存活的对象统一复制到另一块区域，解决了内存碎片问题，但会增加停顿时间
3. 标记-整理算法：将存活的对象统一往一个方向移动，解决了内存碎片问题，但也会增加停顿时间
4. 分带收集：将JVM分成不同区域，每种区域使用不同的垃圾回收方法
```

* 新生代代：用于存放新创建的对象，采用复制回收方法，如果s1与s2之间复制一定次数后，转移到老年代中。这里的垃圾回收叫做minor GC
* 老年代：这些对象垃圾回收的频率较低，采用标记整理方法，也是堆新生代的担保，叫做 major GC

* 新生代分成三个区域：Eden，from survivor，to survivor



### 垃圾回收器

* 串行收集器：**Serial/Serial Old** 

  以单线程的方式收集，垃圾回收的时候，要暂停所有用户线程。其中**Serial**是针对新生代的收集器，采用复制回收算法，**Serial Old**是针对老年代的收集器，采用的是标记整理算法。优点是实现简单高效，缺点是会给用户带来停顿

* 多线程收集器：**ParNew** 

  以多线程的方式进行收集，就是串行收集器的多线程版本，是除串行收集器之外，**新生代的首先收集器**，因为它可以与CMS收集器配合使用

* 并行收集器

  * Parallel Scavenge ：新生代的多线程且并行收集器，不需要暂停其它用户线程，采用复制算法
  * Parallel Old：老年代收集器，使用标记整理算法 

* CMS 收集器

  是一种以**获取最短回收停顿时间为目标**的收集器，是一种并发收集器，采用**标记清除算法**，会触发Full GC

* G1收集器

  1. 并行与并发
  2. 分代收集，和串行收集器使用的算法一样，但是它将内存划分成Region概念，回收的时候按Region为单位回收



参考：

https://www.cnblogs.com/xing901022/p/7725961.html

https://blog.csdn.net/u012152619/article/details/46968883

http://www.importnew.com/19085.html

http://www.cnblogs.com/chengxuyuanzhilu/p/7088316.html