## 适配器模式 ##
**功能**：将一个类的接口(adaptee)转换成客户端能够接受的接口(target)，**解决了客户端接口和服务端接口耦合关系**

* Target：目标接口
* Adaptee：需要适配的接口
* Adapter：适配器，将源接口适配成目标接口

* **继承源接口，实现目标接口**

**举例：**   
inputStreamReader：将字节转换成字符  

* 目标接口是 Reader
* 源接口是 inputStream
* 它持有 inputStream 的引用，并实现了Reader接口

**归纳：**  

* 首先客户端给了一个客户端接口，让我按照特定的数据格式给它返回数据
* 但是我现在通过一个现成的服务端接口得到的数据，不符合这个接口的要求
* 我肯定要实现客户端接口，**在实现类中继承或者依赖服务端接口**
	* 在实现客户端接口的方法内，调用客户端接口，得到数据，再对数据进行处理后返回


## 装饰器模式 ##
**功能：** 将某个类装扮一下，使它功能更强大，不改变类结构，对使用者透明，**解决了业务功能和非业务功能的耦合问题**

* Component：被装饰对象的抽象类
* ConcreteComponent：component的实现类
* Decorator：装饰器角色，持有一个component对象的引用，并实现了该接口
* concreteDecorator：具体装饰器实现类，**构造器注入一个具体的Component对象，并覆盖Decorator实现的component接口，在实现方法中，调用ConcreteComponent方法，并添加自己的方法**

**举例：**  
BufferedInputStream：将fileInputStream读取的流，保存在内存中  

* inputStream 是 component
* fileInputStream 是 concreteComponent
* FilterInputStream 是 装饰类 
* BufferedInputStream 是 装饰后的类

**归纳：** 

* 我有一个类，但是想在这个类的基础上，添加一些功能
* 在不修改这个类和**对客户端透明**的前提下
	* 我必须重新设计一个它的**兄弟类**，也就是要**实现相同的接口**
	* 并且**依赖基础实现类**，并在装饰类的方法中，调用基础类的方法
	* 并在具体装饰类中，**通过构造器注入基础实现类**，并实现增强方法


## 适配器模式与装饰器模式的区别 ##
* 他俩都有一个别名：包装模式，都起到包装一个类或对象的作用
* 适配器模式：**将服务端接口包装成客户端需要的接口**
* 装饰器模式：**将一个类，包装增强成一个兄弟类**，其中有特定的增强方法
* 一个是实现接口，一个是增强类


## 访问者模式 ##
**功能：**将稳定的数据结构(节点数据不编号)和不断变化的数据访问者（每个访问者对节点的操作不一样）解耦，定义不同的访问者，不会改变数据结构。所以需要在节点中，添加一个accept方法，接收不同的访问者，并将节点自身传给访问者的view方法。这样节点的结构永远不会变，这是在各个访问者中，提取节点的数据，并对数据做不同的处理。**解决了数据结构和访问者之间的耦合关系**

* Element：抽象节点元素，提供一个接口，接收不同的访问者对象
* ConcreteElement：具体节点元素，实现节点元素接口，在方法中调用访问者的view方法，并将自身当作参数传给访问者


* Vistor：抽象访问者，声明所有访问者需要的接口，每个接口，对应不同的节点中的数据类型，如：节点中有消费账单、收入账单两种类型，那么就需要声明两个接口
* ConcreteVistor：具体访问者，实现接口，对不同的节点类型做不同的处理


* ObjectStructure：结构对象，提供一个接口，能够访问到所有节点元素
* Client：客户端，分别创建访问者和节点元素的对象，调用访问者访问节点

**举例：**Javac 中的语法分析过程  

* tree：抽象节点元素
* JCIf、JCTry、JCBreak、JCReturn 是不同的节点元素，节点元素种类基本不会变了  
* vistor：抽象的访问者
* TreeScanner、Enter、Attr、Gen 等是具体访问者
* JCCompilationUnit：结构对象，持有整个语法树，即所有元素节点集合
* JavaCompiler：客户端，同时持有节点元素和访问者，操作不同的访问者访问同一语法树
* 点击查看[访问者模式代码][1]

**归纳：**  

* 有固定的1个或多个节点元素
* 有不固定的访问者
* 在每个访问者中有多个查看方法view，分别查看不同的节点
* 每个节点中都有一个accept方法接收不同的访问者
* **关键**
	* 在结构对象中，遍历节点对象
	* **将访问者作为参数，传给节点对象**
	* **这样就有两次动态分配过程了！**
		* 第一次，节点是动态决定的，传入的访问者是静态类型
		* 第二次，在accept方法中，访问者的调用时动态类型，节点是静态的了，但是现在的节点的静态类型已经动态分配过滤
	* 如果将节点作为参数，传给访问者，那么只有一次动态分配，因为传入的是节点的静态类型，访问者就不能区分不同类型节点了！

* **最关键的概念是，访问者模式，用来动态多分配的方法，同时区别了不同的节点实例，和不同的访问者实例**

## 门面模式 ##
**功能：**提供一个高层次的接口，将一些复杂的流程封装到此接口中，使得子系统更容易使用，**解决了各个系统之间的耦合关系**  

* Facade：门面角色，客户端可以调用这个角色的方法，该角色将请求委派到相应的子系统中
* subsystem：子系统角色，供门面角色调用，对子系统而言，门面仅仅是一个客户端角色

* 在Tomcat中有很多组件，每个组件要相互交互数据，通过门面可以很好的隔离数据

**举例：**  

* HttpRequestFacade类封装了HttpRequest接口，通过HttpRequestFacade访问到的数据都被代理到HttpRequest中


## 观察者模式 ##
**功能：** 也即发布-订阅模式，也就是事件监听机制，它定义了一种一对多的依赖关系，一个主题，多个观察者，当主题发生变化时，会主动通知观察者，这样观察者便能针对主题发生的变化，执行某些对应的动作，**解决了主题和观察者之间的耦合关系**

* Observable：抽象主题，定义了管理观察者的添加、删除和通知方法
* Container：具体主题，对观察者进行管理，并在自身发生变化时，通知观察者
* Observer：抽象观察者，定义主题发生变化时，具体观察者必须执行的方法
* ContainerConfig：具体观察者，实现了当主题发生变化时，应该执行的动作

**举例：**Tomcat生命周期管理  

* Lifecycle:相当于抽象主题角色，所有的容器类与组件实现类都实现了这个接口。如StandardContext
* LifecycleListener:相当于抽象观察者角色,具体的实现类有ContextConfig, HostConfig, EngineConfig类，它们在容器启动时与停止时触发
* LifecycleEvent:生命周期事件，对主题与发生的事件进行封装
* LifecycleSupport:生命周期管理的实用类，提供对观察者的添加，删除及通知观察者的方法
* LifecycleException:生命周期异常类
* 点击查看[观察者模式代码][2]  

**归纳：**

1. 访问者模式和观察者模式区别

```java
//观察者模式
public void notifyObservers() {  
    for(Observer observer:observers)  {  
        observer.update(this, "start");//在主题中调用观察者方法  
    }  
}  
```

```java
//访问者模式
public void show(AccountBookViewer viewer){
    for (Bill bill : billList) {
        bill.accept(viewer);//在结构对象中，调用节点方法，并传入访问者
    }//和观察者模式的区别，就在于，闯入一个访问者，并在accept方法中调用该访问者方法
}

public void accept(AccountBookViewer viewer) {
    viewer.view(this);
}
```

* 相同点
  * 都是在一个对象中，调用另一个对象的方法，有一个被动的对象
  * 观察者模式是在主题中调用观察者对象的update方法
  * 访问者模式中是在结构对象中调用节点的accept方法
* 不同点
  * 访问者模式的**访问者相当**于观察者模式中的主题
  * 但是访问者模式中的主题有多个，而且也是被动对象
  * 访问者模式是动态双分配，观察者就是动态分配

## 命令模式

**功能：**封装命令，为了解决 **命令请求者** 和 **命令实现者** 之间的耦合关系，**方便对命令做各种控制，可以分别对请求进行处理，和对执行者进行处理**，如添加日志

1. 更方便的对命令进行扩展
2. 对多个命令的统一控制

* Client：创建一个命令，并决定接受者
* Command：定义命令的统一接口
* ConcreteCommand：具体命令，用来执行具体命令，某些情况下可以直接用来充当Receicer
* Invoker：请求者，是命令模式中最重要的角色。这个角色用来对各个命令进行控制
* Receiver：命令的实际执行者

**举例：**Tomcat中Connector与Container组件之间的命令模式

* Connector：抽象请求者
* HttpConnector：具体请求者
* HttpProcessor：命令接口
* Container：抽象接受者
* ContainerBase：具体接受者
* Server：客户端
* Server首先创建命令请求者HttpConnector对象，然后创建命令HttpProcessor对象，再把命令对象交个命令接受者ContainerBase容器来处理
* 点击查看[命令模式代码][3]

**归纳：**

* 在命令请求者中，依赖了抽象命令
* 每个具体命令中，依赖了抽象接收者
* 这样在命令请求者中，调用抽象命令，其实调用了具体接收者的方法

* 命令模式实现了**命令请求者** 和 **命令实现者** 的解耦
* 可以在不改变命令请求者的逻辑下，改变命令实现者，达到改变命令请求者功能的目的
  * 如修改热键
* 可以实现REDO/UNDO操作，只要在抽象命令中增加相应方法，在具体实现者中实现
* 命令模式是将功能提升到对象来操作，以便对多个功能进行一系列的处理以及封装 



## 责任链模式

**功能：**在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任

**举例：**

* Tomcat中容器的设计
* Spring中的Filter



## 代理模式

**功能：**通过代理类，来扩展实际类的功能，而不改变实际类

* Subject：抽象主题
* RealSubject：抽象主题实现类，被代理的类
* ProxySubject：代理类

点击查看[代理模式代码][4]

## 策略模式

**功能：**策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化 

* Context：使用不同策略的环境，持有一个抽象策略的引用
* Strategy：抽象策略
* ConcreteStrategy：具体策略实现类，有多个

**举例：**

* Spring代理方式的选择，JDK动态代理和CGLIB代理
* Spring解析XML文件时，针对不同节点元素采用不同的解析方法
* 点击查看[策略模式代码][5]

**归纳：**

1. 策略模式的使用场景
   * 针对同一类型问题的多种处理方式，仅仅是具体行为有差别时 
   * 需要安全地封装多种同一类型的操作时 
   * **出现同一抽象类有多个子类**，而又需要使用 if-else 或者 switch-case 来选择具体子类时 



## 工厂模式

* 能够将对象的创建集中化
* **改变对象的创建方式将会变得很容易**

## 图示 ##
### 访问者模式 ###
![访问者模式](https://raw.githubusercontent.com/wangkang09/knowledge-summary/master/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/cite/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.png )
### 门面模式 ###
![门面模式](https://raw.githubusercontent.com/wangkang09/knowledge-summary/master/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/cite/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F.gif)



## 参考文献

[《深入分析 Java Web 技术内幕》](http://许令波)

[设计模式学习之访问者模式](https://blog.csdn.net/u012124438/article/details/70537203)

[Tomcat生命周期管理与观察者模式](https://www.cnblogs.com/chenying99/archive/2012/09/05/2671199.html) 

[理解设计模式之----命令模式](https://www.cnblogs.com/konck/p/4199907.html)

[设计模式学习之策略模式](https://blog.csdn.net/u012124438/article/details/70039943/)

[1]:./cite/访问者模式代码.html
[2]:./cite/观察者模式代码.md
[3]:./cite/命令模式代码.md
[4]:../动态代理与静态代理.md
[5]:./cite/策略模式代码.md