## 共享对象的并发读写 ##

### 1. 读写锁 ###

#### 定义： ####
* 读写锁实际是一种特殊的自旋锁
* 它把对共享资源的访问者划分成读者和写者
* 一个读写锁同时只能有一个写者或多个读者（与CPU数相关），但不能同时既有读者又有写者

#### 优点： ####
* 多个读线程可以并发

#### 问题： ####
* 最大可能的读者数为实际的逻辑CPU数。写者是排他性的
* 在读写锁保持期间也是抢占失效的
* 如果读写锁当前没有读者，也没有写者，那么写者可以立刻获得读写锁，否则它必须自旋在那里，直到没有任何写者或读者
* 如果读写锁没有写者，那么读者可以立即获得该读写锁，否则读者必须自旋在那里，直到写者释放该读写锁

---
### 2. 引用计数的问题 ###

#### 定义： ####
* 类似Copy on write的方式，每次更新时都构造新的对象
* 在更新过程中，读取操作还是读取旧的对象
* 更新操作完成后，原子的替换掉指针使其指向新的对象
* 而被替换掉的对象**不能立即释放**，而是要确保这个**对象不再被继续使用**的情况下，才能将其释放掉
* 使用**引用计数机制**，在读取前将引用计数加1，读取完毕后将引用计数减1，当引用计数减到0的时候，表示没人在使用这个对象，可以将其释放掉

#### 优点： ####
* 多个读一个写不阻塞

#### 问题： ####
* 取得全局指针g_conf和通过这个指针操作对象的引用计数这两个操作**并非原子的！**
* 一个线程取得**变量指针**后，引用计数没加1，被切换了，另一个线程操作变量，变更了此变量的指针，但切换到第一个线程时，此线程取得的指针已经失效

---
### 3. 带锁的引用计数 ###

#### 定义： ####
* 将读写g_conf和修改引用计数两个操作放在一个独立全局锁（g_lock）的临界区执行
* **通过读写锁，使2的两个操作原子化**
* 有锁引用计数，主要是用了**范围更小读写锁**，更改的时候，别的线程仍然可以更改，**只有替换引用的时候，会阻塞其他线程**，替换引用！
* 点击查看[带锁引用代码逻辑分析][4]

#### 优点： ####
* 解决了引用计数的非原子操作问题


#### 问题： ####
* 一方面可能存在读者或写者被饿死的情况
* **另一方面多个写者无法并发**
* 应用在copy on write btree等数据结构中时，多个写者相互阻塞的问题会影响到整个数据结构的并发性能

---
### 4. 无锁的引用计数 ###

#### 定义： ####
* 无论读取g_conf还是替换g_conf都不在锁中进行
* 每次构造新的GConf对象的要同时分配新的RefNode来保存GConf对象的地址
* RefNode对象的分配和释放由专用的分配器进行分配和重用，一旦分配就不会释放回系统，分配器是一个定长的数组，gnode的node_idex就是数组的下标
* **改变的是gnode，用新的gnode覆盖旧的gnode这是原子操作**
* **通过GNODE，使2的两个操作原子化**
* 点击查看[无锁引用代码逻辑分析][1]

#### 优点： ####
* 读写完全并发
* 无锁

#### 问题： ####

* 每次**读取**都需要使用原子操作改变引用计数，高并发情况下，对同一变量的原子操作可能成为性能瓶颈
* 管理RefNode对象的无锁分配器有额外的管理和维护成本，增加了实现复杂度
* 针对每个共享对象都需要维护N个(线程个数)RefNode，如果共享对象数量较多(Btree节点)，为节省空间，还需要额外的机制，避免大量使用RefNode

---
### 5. HazardPointer ###

#### 定义： ####
*  将可能要被访问到的**共享对象指针(hazard pointer)先保存到线程局部**，访问完成后从线程局部移除
*  释放一个共享对象时，则要先遍历查询所有线程的局部信息
	*  如果尚有线程局部保存有这个共享对象的指针，说明有对象可能访问，不能释放
	*  只有所有线程局部信息中都没有保存这个共享对象的指针情况下，才能释放
* 点击查看 [hazardPointer 代码逻辑分析][2]

#### 优点： ####
* 解决了引用计数原子操作的性能瓶颈，读取的时候不需要递增，只有写操作才用
* 避免了实现额外RefNode无锁分配器的复杂度

#### 问题： ####
* 回收内存的操作需要变量查询全局数组g_hp_array，代价比较大
* 通常工程上做法
	* 将待回收的指针暂存在线程局部
	* 等数量超过一个配置门限实时，才进行批量回收
	* 问题：回收产生延迟，并且回收操作本身需要遍历数组，耗时较多
	* 关于并发场景，由于回收操作遍历数组，并不能保证原子的遍历
	* 而HazardPointer的设计要求对象已经放入g_hp_array后能够安全访问
* 需要为每个共享变量维护N个槽位

---
### 6. HazardVersion ###

#### 定义： ####
* 基于 hazardPointer 发展的
* 提供类似 lock 一样的 acquire/release 接口
* 支持无限制个共享对象的管理
* 全局维护一个int64_t类型的 GlobalVersion
* 访问共享对象前，先将当时的GlobalVersion保存到线程局部，称为hazard version
* 每次要释放共享对象的时候，先将当前GlobalVersion保存在共享对象
* 然后将GlobalVersion 原子+1
* 然后遍历所有线程的局部信息，找到最小的version称为reclaim version
* 判断
	* 如果待释放的对象中保存的version小于reclaim version，则可以释放
	* 否则不可用
* 点击查看 [hazardVersion 代码逻辑分析][3]

#### 优点： ####
* hazardVersion局部变量数组保存的是数字类型，比hazardPoint保存指针，消耗少
* hazardPoint 读取变量的时候，线程数组中，要通过循环确保线程组中保存的是最新的，因为释放的时候要比较指针相等
* 而hazardVersion 线程数组中保存的是 版本号，不需要最新的版本号，只要读取的变量最新就行，因为释放时，比较的是版本号，即使这一次没释放，后面还能释放

#### 问题： ####
* 同 hazardPointer相同

## 总结 ##
1. 当读写比例很大时，或者内存要求高时，使用带锁引用计数要好
2. 当读写比例不是很大，并且要求高并发时，使用hazardVersion

## 问题 ##
1. 此文献是用 c++ 来写的，所有必须手动释放内存，而 Java 不需要，所以可以不考虑引用数
2. Copy on Write 不适用与大变量，因为频繁创建大变量，会造成频繁的 full GC
3. 这里的方法，不能针对有累计状态的变量，累计变量不能用多个并发写
4. 所以针对集合，只能使用带锁引用，而 Java 不需要引用数，会更简洁
5. 所以无锁引用及其优化，都不能使用在累计变量中
6. **无锁引用主要解决无锁数据结构中内存释放的问题**

## 附图 ##
### 1 无锁引用图 ###
![无锁引用图](https://raw.githubusercontent.com/wangkang09/knowledge-summary/master/java/Concurrency/img/%E6%97%A0%E9%94%81%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%9B%BE.jpeg "无锁引用图")


[1]:./cite/无锁引用计数.md
[2]:./cite/hazardPointer代码逻辑.md
[3]:./cite/hazardVersion代码逻辑分析.md
[4]:./cite/带锁引用计数逻辑.md

