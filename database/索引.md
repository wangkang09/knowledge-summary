## 索引

**InnoDB索引和MyISAM索引的区别**

* 主索引的区别：InnoDB的数据文件本身就是索引文件，它的叶子节点是完整的数据。而MyISAM的叶子节点存储的是指向数据的指针
* 辅助索引的区别：InnoDB的叶子节点存在的是主键的值。MyISAM主索引和辅助索引一样

Oracleb+树索引和MyISAM索引一样



**B树与位图索引**

* B树索引非常适合于OLTP系统，其用户执行的都是常规的查询
* 在OLTP系统中，数据会频繁地更新和删除，如果使用位图索引将会引起严重的锁定性能问题
* 使用位图索引，优化器可以高效地执行包含AND，OR或者XOR的查询
* 优化器可以回答对null的查询和计数。null值在位图索引时同样被加上索引（不像B树索引）
* B树使用于范围查询，位图使用于OLAP大数据的复杂查询



**数据库为什么要用B-Tree索引**

* 局部性原理与磁盘预读：当一个数据被用到时，其附近的数据也通常会马上被使用，为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存
* 数据库系统巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入
* B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O（h）=O（logmN）。一般实际应用中，m是非常大的数字，通常超过100，因此h非常小（通常不超过3）
* **至于真正的深度的平衡，是按照算法来去做分裂和合并平衡的**
* 而红黑树这种结构，**h**明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O（h），效率明显比B-Tree差很多



**几个数的区别**

* **二叉树：**二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；

* **B-树：**多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；

所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；

* **B+树：**在B-树基础上，**为叶子结点增加链表指针**，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；**B+树总是到叶子结点才命中**；

* **B*树：**在B+树基础上，**为非叶子结点也增加链表指针**，将结点的最低利用率从1/2提高到2/3



**注意：各个数的非叶节点的值肯定是不一样的，但是叶节点的key值可以一样，value不一样即可**

**B-Tree**可以有重复的key，没有影响



Oracle中重复率很高的字段创建B树索引，为什么性能可以得到大幅提升

请教一个让我不解的问题：
我有一张表TT，数据大概是240W，其中的一个字段COL1的值只有‘0’和‘1’两个。现在有如下查询：SELECT COL2,SUM(NVL(COL3,0) * nvl(COL4,0))
FROM TT
WHERE COL1 = '0'
GROUP BY COL2;
在查询耗时大概是 50s。
为了提高性能，在TT表的COL1字段上创建了位图索引，查询耗时变为 2s
但是由于我需要对TT表做大量的Insert和Update操作，位图索引锁表的风险很大，所以只能放弃使用。
因为TT表的数据量还在增大，我们的DBA建议我把这个表修改为分区表，但是，我自己又不想动生产的数据库。所以在COL1上建了一个普通B树索引试了下，发现性能大幅提升，耗时也是2s左右，B树索引起了很大作用。
在我的概念里，重复率高的字段是肯定不适合建B树索引的，强制使用B树索引反而会因为增加索引开销，比全表扫描还要慢些。所以请教各位高手，在COL1字段上建B树索引为什么可以起到这样的效果？



答：首先可能是col1=0的数据量不是很大。如果按照120万来算，按索引查询为2s，我觉得全表扫描用不到4秒。所以肯定是group by的时候内存不够了，导致磁盘排序



![](img\b树.png)









转自：

https://blog.csdn.net/bigtree_3721/article/details/73151472

https://blog.csdn.net/tswisdom/article/details/7396826

https://blog.csdn.net/zcw9202905/article/details/77287748