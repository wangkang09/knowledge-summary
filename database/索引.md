## 索引

**InnoDB索引和MyISAM索引的区别**

* 主索引的区别：InnoDB的数据文件本身就是索引文件，它的叶子节点是完整的数据。而MyISAM的叶子节点存储的是指向数据的指针
* 辅助索引的区别：InnoDB的叶子节点存在的是主键的值。MyISAM主索引和辅助索引一样

Oracleb+树索引和MyISAM索引一样



**B树与位图索引**

* B树索引非常适合于OLTP系统，其用户执行的都是常规的查询
* 在OLTP系统中，数据会频繁地更新和删除，如果使用位图索引将会引起严重的锁定性能问题
* 使用位图索引，优化器可以高效地执行包含AND，OR或者XOR的查询
* 优化器可以回答对null的查询和计数。null值在位图索引时同样被加上索引（不像B树索引）
* B树使用于范围查询，位图使用于OLAP大数据的复杂查询



**数据库为什么要用B-Tree索引**

* B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O（h）=O（logmN）。一般实际应用中，m是非常大的数字，通常超过100，因此h非常小（通常不超过3）
* 而红黑树这种结构，**h**明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O（h），效率明显比B-Tree差很多

* 局部性原理与磁盘预读：当一个数据被用到时，其附近的数据也通常会马上被使用，为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存
* 数据库系统巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入
* **至于真正的深度的平衡，是按照算法来去做分裂和合并平衡的**

  



**几个数的区别**

* **二叉树：**二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；

* **B-树：**多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；

所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；

* **B+树：**在B-树基础上，**为叶子结点增加链表指针**，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；**B+树总是到叶子结点才命中**；

* **B*树：**在B+树基础上，**为非叶子结点也增加链表指针**，将结点的最低利用率从1/2提高到2/3



**注意：各个数的非叶节点的值肯定是不一样的，但是叶节点的key值可以一样，value不一样即可**

**B-Tree**可以有重复的key，没有影响



Oracle中重复率很高的字段创建B树索引，为什么性能可以得到大幅提升

请教一个让我不解的问题：
我有一张表TT，数据大概是240W，其中的一个字段COL1的值只有‘0’和‘1’两个。现在有如下查询：SELECT COL2,SUM(NVL(COL3,0) * nvl(COL4,0))
FROM TT
WHERE COL1 = '0'
GROUP BY COL2;
在查询耗时大概是 50s。
为了提高性能，在TT表的COL1字段上创建了位图索引，查询耗时变为 2s
但是由于我需要对TT表做大量的Insert和Update操作，位图索引锁表的风险很大，所以只能放弃使用。
因为TT表的数据量还在增大，我们的DBA建议我把这个表修改为分区表，但是，我自己又不想动生产的数据库。所以在COL1上建了一个普通B树索引试了下，发现性能大幅提升，耗时也是2s左右，B树索引起了很大作用。
在我的概念里，重复率高的字段是肯定不适合建B树索引的，强制使用B树索引反而会因为增加索引开销，比全表扫描还要慢些。所以请教各位高手，在COL1字段上建B树索引为什么可以起到这样的效果？



答：首先可能是col1=0的数据量不是很大。如果按照120万来算，按索引查询为2s，



![](img\b树.png)



## B+树

* B+树和**B-Tree一样，一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)** ，通过d都很大，所以h很小
* 在B-树基础上，**为叶子结点增加链表指针**，所有关键字都在叶子结点中出现，非叶子节点不会命中
* 所有的叶节点都在同一层，叶子节点之间通过链表相连，这样有利于范围查询
* B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点 。所以B+树有两种访问方式，一种通过根节点，一种通过最小关键码节点（如果是范围查询的话，可能是通过根节点找到第一个数，在通过第二种方式找，而B树因为数据分散，所以叶节点之间不能使用指针相连）
* 首先B+树只有叶节点才指向真实数据，这样可以将同一个节点下的数据的物理地址存放在一起，有效的利用了磁盘预读（每次读取数据的时候，都会顺序读取后面一定长度的数据，局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用）



## B树定义

* 每个结点的属性
  * x.n: 每个结点包含的关键字个数
  * x.key1, x.key2, x.key3.....x.keyn, 以非降序排列
  * x.leaf, 表示x结点是否是叶子结点
  * x.ci: 每个结点还包含x.n+1个孩子指针x.c1, x.c2, x.c3......x.cn+1

```java
//大概是这种数据结构吧
public class BTree {
    private BTreeNode node;
    private List<BTreeNode> NodeLists;
    
    public static class BTreeNode {
        private int address;//物理地址
        private BTreeNode next;
        private String keyWord;
        private Boolean leaf;//是否是叶子节点
    }
}
```







参考：

https://blog.csdn.net/bigtree_3721/article/details/73151472

https://blog.csdn.net/tswisdom/article/details/7396826

https://blog.csdn.net/zcw9202905/article/details/77287748

https://blog.csdn.net/kennyrose/article/details/7532032

https://blog.csdn.net/cyongxue/article/details/16971337