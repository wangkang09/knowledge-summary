# 面经1

1. 数据库事务的几个性质

   2. 原子性：一个事务中的所有sql，要么都运行成功，全部提交，只要有一个运行不成功，则全部回退

   3. 一致性：一个事务完成数据库的操作，操作后的数据要和预期的数据一致，即一个事务在操作某个数据时，其它事务不能对其更改，直到这个事务提交或者回退

   4. 隔离性：有四个隔离级别，最关键的是，每个隔离级别，对数据的更新操作都是对当前行的操作，而对数据的读取操作，一般是对不同版本的快照操作的，这样实现了读写分离

   5. 持久性：事务操作数据库后，操作日志就被记录下来了，大概分为两种
      1. 完全持久：事务提交后，会把事务日志先写到磁盘，之后再将结果返回客户端
         1. 系统无法承受任何数据丢失
         2. 造成性能瓶颈的原因不是事务日志写入磁盘
      2. 延时持久：在事务日志写入磁盘前，就可以将结果返回客户端
         1. 事务日志不用实时写入磁盘，减少了磁盘资源争用，提高了事务的吞吐量
         2. **需要忍受一定数据的丢失**
         3. 如果瓶颈发生在日志写入的时候，可以用延时持久代替

2. 80个球有一个有问题找出有问题的
   1. 分成26 26 26  2 
   2. 比较 26 26
      1. 若相等，说明第三个26有问题，再用第一个26和第三个比，得出有问题的是重还是轻
      2. 若不相等，说明第三个26没有问题，假设第一个重，再用第三个和第一个比，如果相等，说明第二个有问题，其有问题的轻
      3. 综上通过**2次比较**就能得出哪一堆有问题，且有问题的是重还是轻
   3. 将有问题的分成3份，9 9 8，比较 9 9，可以得出有问题的
   4. 将有问题的分成3份 3 3 2/3 ，可以得出有问题的
   5. 将有问题的分成3份 1 1 0/1，可以得出有问题的
   6. 尽量将份数分成3的n次方的形式，剩下的就放在第四堆

3. 数据库的备份与恢复原理

   通过归档日志和在线日志，来进行备份与恢复的

4. 数据库主从复制实现原理

   mysql是通过binlog来实现的，主库没执行完一个事务就会产生一条binlog日志，从库用一个I/o线程去获取binlog日志，并有一个sql线程堆binlog日志进行回放，binlog日志有两种模式，一种是语句模式记录sql语句，一种是row模式记录数据的变化，一种是混合模式，为了解决row模式无法记录存储过程的一些变化

   oracle是通过同步在线日志或归档日志的增量变化，来实现同步的

5. 进程间通信方式有哪些

   1.  管道：是一种半双工的通信方式，数据只能单向流动
   2.  信号量：是一个计数器，用来控制多个线程堆共享资源的访问
   3.  信号：用于通知接收进程某个事件已经发生
   4.  消息队列：是一个订阅-发布模式，有一个topic的概念，同一个topic的订阅者和发布者才能互相通信
   5.  共享内存：映射一段能被其它进程所访问的内存，有一个进程创建，被多个进程访问
   6.  套接字：

6. 黑名单可能需要动态地增删改，如何设计才能避免访问响应太慢 

   加缓存，分片

7. 求斐波那契数列

   1. 递归求：f(n) = f(n-1) + f(n-2)，效率低，重复计算

   2. 从第一项开始求，无重复计算，线性时间

   3. [矩阵链乘法][1]：

      ![](img\矩阵链乘法.png)

8. [单例模式][2]

   ```java
   public class Singleton {
       private volatile Singleton singleton;
       private Singleton(){};
       public Singleton getSingleton() {
           if(singleton == null) {
               synchronized (this) {
                   if(singleton==null) {
                       singleton = new Singleton();
                   } 
               }
           }
           return singleton;
       }
   }
   ```

   

9. 栈和队列的区别

   1. 相同点
      1. 都是操作受限制的数据结构，只能在尾部插入数据
      2. 都是线性结构
      3. 都可以通过顺序结构和链式结构实现
      4. 插入和删除的时间复杂度都是O(1)
   2. 不同点
      1. 栈是FILO（入栈和出栈都操作尾部），队列是FIFO（从尾部入队列，头部出队列）

10. 两个栈实现队列，[两个栈实现最小值栈][3] 

    ```java
    1、入栈的时候直接入栈A，出栈的时候，如果栈B不为空，则直接出栈B，否则，将栈A的数据全部出栈到栈B，再出栈栈B
    2、栈A正常存储数据，栈B用来存储最小值，每当入栈A时，将新来的数据和栈B中尾部数据比较，将较小的数据入栈B
    ```

11. Java中一般用什么类型表示价格 

    ```java
    答：Java语言提供了另外一种数据类型BigDecimal，可以表示精确的浮点数，适合用作财务计算的数据类型。但是需要注意的是，在使用BigDecimal的时候，BigDecimal有多个重载的构造方法能表示精度的值，只有用参数为String类型的构造方法才能表示
    ```

12. 内存，虚拟内存和页面置换 

13. 高并发场景分析，怎么解决，从前端到后端到数据库到系统的优化策略 

    1. 加缓存
    2. 将一些逻辑放到前端去处理，减少后端的压力
    3. 后端采取分布式和集群来做，不同的业务单元通过微服务拆分开了，做分布式应用，每个微服务再做集群
    4. 数据库：可以采用分布式数据库

14. 缓存穿透，缓存击穿，缓存雪崩解决方案分析

    1. 缓存穿透

       定义：指查询一个不存在的数据，由于缓存没命中，则每次都去数据库查询，数据库压力很大，并且别人可以利用这个不存在的key频繁攻击我们的应用

       解决方案：一是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截，从而避免了对底层的查询。二是将数据库返回的空值，也进行缓存，设定一定的过期时间

    1. 缓存击穿

       定义：缓存在某个时间点过期，恰好这个时间点对这个key有大量的并发请求，这样这些并发请求会同时访问数据库

       解决方案：一是使用互斥锁，保证只有一个线程访问数据库，其它等待；二是不设置过期策略，后端程序定时刷新缓存

    1. 缓存雪崩

       定义：缓存击穿是针对一个key的缓存过期问题，而缓存雪崩是争对多个key同时过期的问题

       解决方案：一是加锁保证单线程访问数据库，二是多级缓存，设置不同的缓存时间，三是不同的key设置不同的过期时间

15. 

[1]: https://www.cnblogs.com/guozhenqiang/p/5489081.html
[2]: ./cite/单例模式.md
[3]: ./cite/最小值栈.md