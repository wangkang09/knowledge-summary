# 海量数据和高并发的解决方案

## 1 海量数据的解决方案

1. 使用缓存
2. 使用静态化技术
3. 数据库优化
4. 分离数据库中活跃的数据
5. 批量读取和延迟修改
6. 读写分离
7. 使用NoSQL和Hadoop等技术
8. 分布式部署数据库
9. 应用服务和数据库服务分离
10. 使用搜索引擎搜索数据库中的数据
11. 进行业务拆分

## 2 高并发的解决方案

1. 页面缓存
2. 集群和分布式
3. 反向代理
4. CDN



## 3 缓存

通过一致性hash将数据分布到不同的缓存服务器中，缓存查询的时候可以直接定位特定的缓存服务器



## 4 页面静态化技术

1. 传统的JSP界面，前端的显示是通过后台服务器进行渲染后返回给前端进行解析执行的。而现在提倡前后端分离，后端只提供数据，通过前端浏览器进行数据的渲染，减轻后端服务器的压力
2. 可以将静态资源（HTML/CSS/JS/图片等）放置在缓存服务器上或者CDN[^1]服务器上，一般使用最多的是CDN服务器或nginx服务器提供静态资源功能

* 尽量减少HTTP请求

* 使用CDN

* 使用Gzip压缩请求

* 缓存

  

## 5 正向代理与反向代理

代理服务器：一般指局域网内部的机器通过**代理服务器**发送请求到互联网上的服务器，代理服务器一般作用在客户端

![](./img/代理服务器)



**正向代理服务器**：作用于客户端，在客户端将我们的HTTP请求转发到其它不同的服务器端，实现请求的分发

**反向代理服务器**：作用于服务器端，它在服务器端接收客户端的请求，然后将请求分发给具体的服务器进行处理，然后再将服务器的相应结果反馈给客户端。Nginx就是一个反向代理服务器软件

![](./img/反向代理服务器)

![](./img/反向代理服务器应用)

* 通过反向代理实现：权限认证，拦截，日志，负载均衡



## 6 架构

 **架构的定义**：架构就是一个架子，放一些业务和算法；架构就是对我们重复性业务的抽象和我们未来业务扩展的前瞻

 **架构师能力**：

1. **抽象的能力**：最基本的就是去重，去重在整个架构中体现在方方面面，从定义一个函数，到定义一个类，到提供一个服务，以及模板，背后都是要去重提高可复用率
2. **分类能力**：做软件需要做对象的解耦，要定义对象的属性和方法，做分布式系统的时候要做服务的拆分和模块化，要定义服务的接口和规范
3. **算法（性能）**：它的价值体现在提升系统的性能，所有性能的提升，最终都会落到CPU,内存,IO和网络这4大块上

![](./img/架构能力.png)



![](./img/架构本质.png)

* 在分布式系统中我们会做MySQL分库分表，要从不同的库和表中读取数据，这样SQL就可以使用模板，因为绝大多数SQL语义使相同的，除了路由到哪个库哪个表
* CDN：做网络智能调度优化和多级缓存
* 服务化：做抽象和做服务的拆分
* 消息队列：本质上还是分类，将两个子系统通过队列解构并异步化



**微博的架构**

![](./img/微博架构.png)



![](./img/架构演变过程.png)

![](./img/平台技术挑战.png)

![](./img/正交分解阐述技术架构.png)

* 水平拆分：接口层，服务层，数据存储层
  1. 接口层：做参数的解析，参数的验证，序列化和反序列化 
  2. 服务层：业务逻辑的处理
  3. 数据存储层：做缓存/DB相关的各类组件
* 垂直拆分：业务架构，技术架构，监控平台，服务治理



![](./img/信息流聚合关系.png)

![](./img/知识储备、.png)











**2pc和3pc是分布式事务强一致性的保证**

## 8 paxos、zab、raft

是分布式事务最终一致性的保证

### paxos

* 是一种分布式系统对某一值达成一致的算法，主要思想是2pc和选举机制（少数服从多数）。
* 主要争对的是**多个节点对某一值(logID)提出多个提议（内容）！！**的时候，如果让所有节点统一接受一个节点的提议

例子：

假设有A,B,C,D五台机器。KV系统要Put一个数据[key=whis->val=3305]到这5台机器上。

1. 首先，客户端随机选择一个节点，进行写入提交，这里随机选择了C节点，这时C就是这次提议的发起人，当C收到这个提议的时候，C首先要做的事情是根据当前节点的最新全局globalId，做一次自增操作，假设当时的globalId是0，所以，这个议案就被对应了一个编号，1-->[key=whis->val=3305]
2. globalID是确认事务的发生顺序用的，显然，**只有当两个事务同时发生时，两个事务才会取得同一个globalId**，这是才会发生，**提议竞争的情况**，通过paxos协议保证所有节点选择同一个事务的globalID对应的内容即可，另一个事务，重新获取globalID，这样就保证了globalID的连续性和事务的连续性
3. 如果发生竞争，比如D也拿到了globalId=1，这样不同的事务拿到的全局id一样
   1. 这五个节点就要执行paxos流程，来选取其中的一个事务当作全局变量为1的事务
   2. 首先，C/D生产一个提议ID，将提议ID发送给其它节点，其它节点判断有没有预接受的提议，如果没有或是预接受的提议ID小于此ID，**就预接受此ID**，将预接受信息发送给此ID的提议者。如果已有接受了的提议ID，则将，已接受ID的**内容**，一同发送给此提议者。
   3. 提议者接收了其它节点的信息，如果信息里是自己的提议ID，则将自己的提议内容发给对应的节点，如果信息不是自己的ID，但没有携带内容，说明有比自己更大的提议ID，提前获取了此节点的预接受，则要重新获取更大的提议ID，再一次向该节点提交此ID，意图获取此节点的预接受

### zab

* 重点在于启动时就选主，然后提供正常服务，也就是说只有一个提议者，n-1个学习者。**这个思想正好能满足2pc和3pc的协调者的单点问题！！！**



### raft

* 和zab的区别在于选举的方式，zab时广播式互相计数的方式，发现别人比自己牛逼时，要帮助别人扩散消息，根据本机计数决定谁是主。
* raft是





















参考：

https://www.cnblogs.com/shanyou/p/5048099.html?utm_source=tuicool&utm_medium=referral

https://baijiahao.baidu.com/s?id=1609465825718473855&wfr=spider&for=pc

https://blog.csdn.net/Lnho2015/article/details/78685503

[^1]: 是一个内容分发网络，通过缓存和负载均衡技术使用户获取最近的数据节点中的内容
